{"version":3,"file":"ngx-elements-router.js","sources":["../../../projects/ngx-elements-router/src/lib/bundle-registry.service.ts","../../../projects/ngx-elements-router/src/lib/entry-routing.service.ts","../../../projects/ngx-elements-router/src/lib/entry-zone.service.ts","../../../projects/ngx-elements-router/src/lib/noop-location-strategy.ts","../../../projects/ngx-elements-router/src/lib/no.component.ts","../../../projects/ngx-elements-router/src/lib/load-bundle.guard.ts","../../../projects/ngx-elements-router/src/lib/routing.directive.ts","../../../projects/ngx-elements-router/src/lib/zone.directive.ts","../../../projects/ngx-elements-router/src/lib/elements-router.module.ts","../../../projects/ngx-elements-router/src/ngx-elements-router.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\n\nfunction load(url: string): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const script = document.createElement('script');\n    script.src = url;\n    script.onload = () => resolve();\n    script.onerror = () =>\n      reject({\n        error: `Bundle ${url} could not be loaded`,\n      });\n    document.body.appendChild(script);\n  });\n}\n\n/**\n * The loading state of a bundle.\n *\n * UNKNOWN -> It has not been tried to load this bundle.\n * LOADING -> The loading of this bundle is currently happening.\n * LOADED -> The bundle has been successfully loaded.\n * FAILED -> The loading of the bundle failed.\n */\ntype LoadingState = 'UNKNOWN' | 'LOADING' | 'LOADED' | 'FAILED';\n\n/**\n * This service loads bundles and keeps track of which bundles have been already loaded.\n * This way, it prevents errors that would occur if a bundle is loaded a second time.\n */\n@Injectable({ providedIn: 'root' })\nexport class BundleRegistryService {\n  private loadingStates: Record<string, LoadingState> = {};\n\n  /**\n   * Loads the given bundle if not already loaded, registering its custom elements in the browser.\n   *\n   * @param bundleUrl The url of the bundle, can be absolute or relative to the domain + base href.\n   */\n  async loadBundle(bundleUrl: string): Promise<boolean> {\n    if (['LOADING', 'LOADED'].includes(this.getLoadingState(bundleUrl))) {\n      return true;\n    }\n    this.loadingStates[bundleUrl] = 'LOADING';\n    const isSuccess = await load(bundleUrl)\n      .then(() => true)\n      .catch(() => false);\n    this.loadingStates[bundleUrl] = isSuccess ? 'LOADED' : 'FAILED';\n    return isSuccess;\n  }\n\n  /**\n   * Returns the loading state of the bundle.\n   *\n   * @param bundleUrl The url of the bundle.\n   */\n  getLoadingState(bundleUrl: string): LoadingState {\n    return this.loadingStates[bundleUrl] || 'UNKNOWN';\n  }\n\n  /**\n   * Returns if the bundle has already been loaded successfully.\n   *\n   * @param bundleUrl The url of the bundle.\n   */\n  isBundleLoaded(bundleUrl: string): boolean {\n    return this.getLoadingState(bundleUrl) === 'LOADED';\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Router, RoutesRecognized } from '@angular/router';\nimport { Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged } from 'rxjs/operators';\nimport { RouterEvent } from './router-event.type';\n\nfunction isRedirect(event: RoutesRecognized): boolean {\n  return event.url !== event.urlAfterRedirects;\n}\n\n/**\n * Registers the routing feature on the entry component of a micro frontend.\n *\n * ```\n * export class ExampleComponent implements OnChanges, OnDestroy {\n *   @Input() route?: string;\n *   @Output() routeChange = new EventEmitter<string>();\n *   route$ = new Subject<string | undefined>;\n *   private destroyed$ = new Subject<void>();\n *   constructor(private entryRoutingService: EntryRoutingService) {\n *     this.entryRoutingService.registerRouting(this.routeChange, this.route$, this.destroyed$);\n *   }\n *   ngOnDestroy() {\n *     this.destroyed$.next();\n *   }\n *   ngOnChanges() {\n *     this.route$.next(this.route);\n *   }\n * ```\n */\n@Injectable({ providedIn: 'root' })\nexport class EntryRoutingService {\n  constructor(private router: Router) {}\n\n  registerRouting(\n    outgoingRoute$: Subject<RouterEvent>,\n    incomingRoute$: Observable<string | undefined>\n  ): Subscription {\n    const inSubscription = this.registerIncomingRouting(incomingRoute$);\n    const outSubscription = this.registerOutgoingRouting(outgoingRoute$);\n    return inSubscription.add(outSubscription);\n  }\n\n  registerIncomingRouting(\n    incomingRoute$: Observable<string | undefined>\n  ): Subscription {\n    return incomingRoute$.pipe(distinctUntilChanged()).subscribe((route) => {\n      if (route) {\n        this.router.navigateByUrl(route, { state: { fromPlatform: true } });\n      }\n    });\n  }\n\n  registerOutgoingRouting(outgoingRoute$: Subject<RouterEvent>): Subscription {\n    return this.router.events.subscribe((event) => {\n      if (\n        event instanceof RoutesRecognized &&\n        (!this.isFromPlatform() || isRedirect(event))\n      ) {\n        outgoingRoute$.next({\n          url: event.urlAfterRedirects,\n          replaceUrl: isRedirect(event),\n        });\n      }\n    });\n  }\n\n  isFromPlatform(): boolean {\n    return this.router.getCurrentNavigation()?.extras.state?.fromPlatform;\n  }\n}\n","import { ApplicationRef, Injectable, NgZone } from '@angular/core';\nimport { EMPTY, Observable, Subscription } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\n\n/**\n * Registers the zone feature on the entry component of a micro frontend.\n * It is intended to be used with the ZoneDirective on the custom element.\n * Together, they ensure that the change detection cycles of the Angular application of a micro frontend are executed.\n * This happens, whenever the `window.Zone` object indicates the necessity of a change detection cycle.\n *\n * ```\n * export class ExampleComponent implements OnChanges, OnDestroy {\n *   @Input() microtaskEmpty$?: Observable<void>;\n *   microtaskEmpty$$ = new Subject<Observable<void>>();\n *   constructor(private entryZoneService: EntryZoneService) {\n *     this.subscription = this.entryZoneService.registerZone(this.microtaskEmpty$$);\n *   }\n *   ngOnDestroy() {\n *     this.subscription.unsubscribe();\n *   }\n *   ngOnChanges() {\n *     this.microtaskEmpty$$.next(this.microtaskEmpty$);\n *   }\n * ```\n */\n@Injectable({ providedIn: 'root' })\nexport class EntryZoneService {\n  constructor(private zone: NgZone, private applicationRef: ApplicationRef) {}\n\n  registerZone(\n    microtaskEmpty$$: Observable<Observable<void> | undefined>\n  ): Subscription {\n    return microtaskEmpty$$\n      .pipe(switchMap((microtaskEmpty$) => microtaskEmpty$ ?? EMPTY))\n      .subscribe(() => {\n        this.zone.run(() => {\n          this.applicationRef.tick();\n        });\n      });\n  }\n}\n","import {\n  APP_BASE_HREF,\n  LocationChangeListener,\n  LocationStrategy,\n  PlatformLocation,\n} from '@angular/common';\nimport { Inject, Injectable, Optional } from '@angular/core';\n\n/**\n * Acts as a noop location strategy that does not modify the browser url.\n * Should be used for a RouterModule in a micro frontend.\n * That way, the RouterModule of the platform is in charge of modifying the browser url.\n *\n * ```\n * imports: [\n *   RouterModule.forRoot([\n *     { path: 'my-route', component: SomeComponent },\n *     { path: '**', component: NoComponent }\n *   ])\n * ],\n * providers: [\n *   { provide: LocationStrategy, useClass: NoopLocationStrategy },\n * ]\n * ```\n */\n@Injectable()\nexport class NoopLocationStrategy extends LocationStrategy {\n  private readonly baseHref: string;\n\n  constructor(\n    private platformLocation: PlatformLocation,\n    @Optional() @Inject(APP_BASE_HREF) baseHref?: string\n  ) {\n    super();\n    this.baseHref = baseHref || this.platformLocation.getBaseHrefFromDOM();\n    if (!this.baseHref) {\n      throw new Error(\n        `No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.`\n      );\n    }\n  }\n\n  onPopState(_fn: LocationChangeListener): void {}\n\n  getBaseHref(): string {\n    return this.baseHref;\n  }\n\n  path(_includeHash: boolean = false): string {\n    return '';\n  }\n\n  prepareExternalUrl(internal: string): string {\n    if (this.baseHref.endsWith('/') && internal.startsWith('/')) {\n      return this.baseHref.substring(0, this.baseHref.length - 1) + internal;\n    } else if (this.baseHref.endsWith('/') || internal.startsWith('/')) {\n      return this.baseHref + internal;\n    } else {\n      return `${this.baseHref}/${internal}`;\n    }\n  }\n\n  pushState(\n    _state: any,\n    _title: string,\n    _path: string,\n    _queryParams: string\n  ): void {}\n\n  replaceState(\n    _state: any,\n    _title: string,\n    _path: string,\n    _queryParams: string\n  ): void {}\n\n  forward(): void {}\n\n  back(): void {}\n}\n","import { Component } from '@angular/core';\n\n/**\n * This component can be used for routes that shall never be resolved by the web component itself.\n * Instead, the host embedding the web component can resolve these routes.\n */\n@Component({\n  selector: 'aer-no-component',\n  template: '',\n})\nexport class NoComponent {}\n","import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, CanActivate } from '@angular/router';\nimport { BundleRegistryService } from './bundle-registry.service';\n\n/**\n * Ensures that a bundle is loaded before activating the route.\n *\n * ```\n * {\n *   path: 'my-micro-frontend',\n *   canActivate: [LoadBundleGuard],\n *   data: {\n *     bundleUrl: 'http://localhost:4200/main.js'\n *   },\n *   loadChildren: () => import('./my-micro-frontend/my-micro-frontend-host.module').then((m) => m.MyMicroFrontendHostModule)\n * }\n * ```\n */\n@Injectable({ providedIn: 'root' })\nexport class LoadBundleGuard implements CanActivate {\n  constructor(private bundleRegistryService: BundleRegistryService) {}\n\n  canActivate(route: ActivatedRouteSnapshot): Promise<boolean> {\n    const bundleUrl = route.data.bundleUrl as unknown;\n    if (!(typeof bundleUrl === 'string')) {\n      console.error(`\n        The LoadBundleGuard is missing information on which bundle to load.\n        Did you forget to provide a bundleUrl: string as data to the route?\n      `);\n      return Promise.resolve(false);\n    }\n    return this.bundleRegistryService.loadBundle(bundleUrl);\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  HostListener,\n  OnDestroy,\n  OnInit,\n} from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { Subject } from 'rxjs';\nimport { map, takeUntil } from 'rxjs/operators';\nimport { RouterEvent } from './router-event.type';\n\n/**\n * Enables the routing feature on a custom element.\n * It passes the activated route into the custom element and listens to route changes of the custom element.\n * The custom element needs to define an input `route` and an output `routeChange`.\n *\n * ```\n * @Component({\n *   selector: 'my-custom-element-host',\n *   template: `\n *     <my-custom-element aerRouting></lx-custom-element>\n *   `\n * })\n * export class MyCustomElementHostComponent {}\n * ```\n */\n@Directive({\n  selector: '[aerRouting]',\n})\nexport class RoutingDirective implements OnInit, OnDestroy {\n  private destroyed$ = new Subject<void>();\n\n  constructor(\n    private element: ElementRef,\n    private router: Router,\n    private route: ActivatedRoute\n  ) {}\n\n  ngOnInit(): void {\n    this.route.url\n      .pipe(\n        map(() => this.router.url),\n        takeUntil(this.destroyed$)\n      )\n      .subscribe((url) => (this.element.nativeElement.route = url));\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed$.next();\n  }\n\n  @HostListener('routeChange', ['$event'])\n  handleRouteChange(event: { detail?: RouterEvent }): void {\n    this.navigateToUrl(event?.detail);\n  }\n\n  navigateToUrl(event: RouterEvent | undefined): void {\n    if (event?.url && event.url.startsWith('/')) {\n      this.router.navigateByUrl(event.url, {\n        replaceUrl: event.replaceUrl || false,\n      });\n    } else {\n      console.warn(\n        `The aerRouting directive received an invalid router event.`,\n        event\n      );\n    }\n  }\n}\n","import { Directive, ElementRef, NgZone, OnInit } from '@angular/core';\n\n/**\n * Enables the zone feature on a custom element.\n * It passes an observable of all events where the global `window.Zone` object reported that the microtask queue is empty.\n * Such an event indicates to Angular that a change detection cycle needs to be run.\n *\n * ```\n * @Component({\n *   selector: 'my-custom-element-host',\n *   template: `\n *     <my-custom-element aerZone></lx-custom-element>\n *   `\n * })\n * export class MyCustomElementHostComponent {}\n * ```\n */\n@Directive({\n  selector: '[aerZone]',\n})\nexport class ZoneDirective implements OnInit {\n  constructor(private element: ElementRef, private zone: NgZone) {}\n\n  ngOnInit(): void {\n    this.element.nativeElement.microtaskEmpty$ = this.zone.onMicrotaskEmpty;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { NoComponent } from './no.component';\nimport { RoutingDirective } from './routing.directive';\nimport { ZoneDirective } from './zone.directive';\n\n@NgModule({\n  declarations: [ZoneDirective, RoutingDirective, NoComponent],\n  imports: [],\n  exports: [ZoneDirective, RoutingDirective, NoComponent],\n})\nexport class ElementsRouterModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"]}